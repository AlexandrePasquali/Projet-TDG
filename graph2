public List<Edge> getEdgesFrom(long id) {
        return adj.getOrDefault(id, Collections.emptyList());
    }

    public List<Edge> getAllEdgesUnique() {
        List<Edge> all = new ArrayList<>();
        for (List<Edge> es : adj.values()) all.addAll(es);

        Set<String> seen = new HashSet<>();
        List<Edge> unique = new ArrayList<>();
        for (Edge e : all) {
            long a = e.getFrom();
            long b = e.getTo();
            boolean oriented = e.isOriented();
            String key = oriented ? a + "->" + b : (Math.min(a, b) + "--" + Math.max(a, b));
            if (!seen.contains(key)) {
                seen.add(key);
                unique.add(e);
            }
        }
        return unique;
    }

    public int degree(long id) {
        if (!adj.containsKey(id)) return 0;
        int out = adj.get(id).size();
        int in = 0;
        for (List<Edge> es : adj.values()) for (Edge e : es) if (e.getTo() == id) in++;
        return in + out;
    }

    public Map<Long, List<Edge>> getAdjacency() { return adj; }

    public boolean isMixed() {
        boolean hasOriented = false, hasUnoriented = false;
        for (Edge e : getAllEdgesUnique()) {
            if (e.isOriented()) hasOriented = true;
            else hasUnoriented = true;
            if (hasOriented && hasUnoriented) return true;
        }
        return false;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Graph (").append(isMixed() ? "mixed" : "undirected").append(")\nVertices:\n");
        for (Vertex v : vertices.values()) sb.append("  ").append(v).append("\n");
        sb.append("Edges:\n");
        for (Edge e : getAllEdgesUnique()) sb.append("  ").append(e).append("\n");
        return sb.toString();
    }
}
